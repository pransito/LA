4*(x^3-1)/3*(x^4-1)
x
x=0.001
4*(x^3-1)/3*(x^4-1)
x=0.00001
4*(x^3-1)/3*(x^4-1)
x=0.00000001
4*(x^3-1)/3*(x^4-1)
x=1.00000001
4*(x^3-1)/3*(x^4-1)
x=1.0001
4*(x^3-1)/3*(x^4-1)
x=1.01
4*(x^3-1)/3*(x^4-1)
(4*(x^3-1))/(3*(x^4-1))
x=1.0001
(4*(x^3-1))/(3*(x^4-1))
4*0.000001
3*0.000001
4*0.000001/3*0.000001
1.0000001^3
1.0000001^4
1.0000001^3-1
f = function (x,y) {
cur_res = abs((x^2+y^2)^(x*y)-1)
return(cur_res)
}
f(1,1)
f(0.01,1)
f(0.01,100000)
f(0.01,1000)
f(0.01,100)
f(0.01,10)
f(0.01,10)
f(0.01,100)
f = function (x,y) {
cur_res = abs(x^3/(x^2+y^2) - 1)
return(cur_res)
}
f(0.01,100)
f(0.01,1)
f(0.001,1)
f(0.001,0.5)
f(0.001,0.5)
f(0.001,0.005)
f = function (x,y) {
cur_res = abs(x^3/(x^2+y^2) - 0)
return(cur_res)
}
f(0.001,0.005)
f(0.001,0.0000000000005)
f(0.001,0.000000000000000000005)
f(0.001,0.00000000000000000000000000005)
f(0.001,0.5)
f(0.001,1000000000)
f(0.001,0.000000000000000000001)
f = function (x,y) {
cur_res = (1/y)*x^(1/y)
return(cur_res)
}
f(0.5,1)
f(0.5,0.001)
f = function (x,y) {
cur_res = x^(1/y)
return(cur_res)
}
f(0.5,0.001)
ln(1)
log(1)
log 1
log (1)
n =100
sqrt(n*n) - sqrt(n)
n=100000
sqrt(n*n) - sqrt(n)
x= (1,2,3,4,5)
x= c(1,2,3,4,5)
g = c(H,C,C,H,C)
g = as.factor(c(0,1,0,1,0))
g
x
aggregate(x,g,mean
)
aggregate(x,b=list(g),mean)
tmp = aggregate(x,b=list(g),mean)
tmp$Group.1
is.data.frame(tmp)
l = c(1,1,0,0)
tmp = aggregate(x,b=list(g,l),mean)
l = c(1,1,0,0,1)
tmp = aggregate(x,b=list(g,l),mean)
tmp
is.data.frame(tmp)
names(tmp)
names(tmp) = c("muh","maeh","miau")
tmp
tmp$muh
tmp$x
tmp$maeh
tmp$x
tmp$miau
cur_fun = function(x) {return(mean,first)}
cur_fun = function(x) {return(c(mean,first))}
cur_fun(x)
cur_fun = function(x) {return(c(mean,x[1]))}
cur_fun(x)
cur_fun = function(x) {return(c(mean(x),x[1]))}
cur_fun(x)
tmp = aggregate(x,b=list(g,l),cur_fun)
is.data.frame(x)
x[[1]]
is.data.frame(tmp)
tmp$Group.1
tmp$Group.2
tmp
set.seed(249);group = rep(1:3, each=2); y = group + rnorm(6); mod = aov(y~factor(group)); summary(mod); TukeyHSD(mod); plot(y~group)
set.seed(249);group = rep(1:3, each=2); y = group + rnorm(6); mod = aov(y~factor(group)); summary(mod); TukeyHSD(mod); plot(y~group)
x=seq(-5,5,length.out = 100)
y=x-x^2
plot(x,y)
max(y)
which(max(y))
which(y==max(y))
y[which(y==max(y))]
x=seq(-5,5,length.out = 1000000)
y=x-x^2
plot(x,y)
y[which(y==max(y))]
max(y)
x=seq(-5,5,length.out = 10000)
plot(x,y)
y=x-x^2
plot(x,y)
plot(x,y)
plot(x,y,xlim = c(-0.3,0.3))
plot(x,y,xlim = c(-0.3,0.5))
plot(x,y,xlim = c(-0.5,0.5))
max(y)
which(y==max(y))
x[which(y==max(y))]
plot(x,y,xlim = c(-1,1))
max(y)
plot(x,y,xlim = c(-1,1),ylim = c(-0.3,0.3))
y==0
which(y==0)
which(y==0.1)
y
which(y>0.1)
which(y>00)
which(y>0)
plot(x,y,xlim = c(-1,1),ylim = c(-0.3,1))
plot(x,y,xlim = c(-1,1),ylim = c(-0.3,0.3))
plot(x,y,xlim = c(-1,3),ylim = c(-0.3,0.3))
exp(seq(-10,10))
plot(exp(seq(-10,10)))
###########################################################
#          VD-ANALYSEN LOSS AVERSION                      #
###########################################################
# 02.11.2012
# fitting a Generalized Mixed Model to the LA data
# DV: accept.reject
# IV (fixed): Gewinn, Verlust, Group
# IV (randm): subject random
## clear workspace
rm(list = ls())
## preparation
# path
user <- "Alexander"
pfad         <- paste("C:\\Users\\", user, "\\Google Drive\\Diplom\\LA\\daten_behav_test_finale_SP_Diplom", sep="")
pfad_data    <- paste("C:\\Users\\", user, "\\Google Drive\\Diplom\\LA\\daten_behav_test_finale_SP_Diplom\\Data", sep="")
pfad_scripts <- paste("C:\\Users\\", user, "\\Google Drive\\Diplom\\LA\\daten_behav_test_finale_SP_Diplom\\Scripts", sep="")
pfad_results <- paste("C:\\Users\\", user, "\\Google Drive\\Diplom\\LA\\daten_behav_test_finale_SP_Diplom\\Results", sep="")
pfad_library <- paste("C:\\Users\\", user, "\\Google Drive\\Library\\R", sep="")
pfad_ransim  <- paste(paste(pfad_results, "\\rand_sim",sep=""))
pfad_R_cit   <- paste("C:\\Users\\", user, "\\Google Drive\\Diplom\\Manuskript\\Lit to be impl in Zotero")
# parameters
des_agg  = 3
# load libraries and functions, options (can be modified)
setwd(pfad_library)
source ('agk_library.R')
setwd(pfad_scripts)
source ('LA_options.R')
# get all the data in long format
setwd(pfad_scripts)
source("get_data_la_2.R")
# only select uncertain gambles
if (only.some == 1){
setwd(pfad_scripts)
source('only_uncertain_gambles.R')
# set the pwd needed
setwd(pfad_data)
}
setwd(pfad_scripts)
source("LA_add_demograpics.R")
# my contrasts
contrasts(data.la$group) <- cbind(c(1, 0, 0), c(0, 0, 1))
colnames(contrasts(data.la$group)) <- c("AD>HC", "PG>HC")
## get the crm
setwd(pfad_results)
load("modc51_majrev.RData")
crm <- agk.get.compl.coef(modc[[3]],"group")
names(crm) <- c("Intercept","betagain","betaloss","beta_ed_abs","group","subject")
crm <- crm[,-5]
crm$lambda <- crm$betaloss*(-1)/crm$betagain
data.la <- merge(data.la, crm, by.x = "subject", by.y = "subject", all.x = TRUE)
## saving the data for export to matlab
setwd(pfad_data)
data.la.aggr           <- aggregate(data.la, by = list(data.la$subject),FUN="first")
data.la.aggr           <- data.la.aggr[,-1]
data.la.aggr$loglambda <- get_log(data.la.aggr$lambda)
# REPLACE GBQ MISSINGS
# overall imputation function (also used later in severity)
imput_fun = function(x) {return(mean(x,na.rm=T))}
data.la.aggr_PG = subset(data.la.aggr,group == "PG")
data.la.aggr_HC = subset(data.la.aggr,group == "HC")
data.la.aggr_AD = subset(data.la.aggr,group == "AD")
data.la.aggr_AD$GBQ_mean_rec[is.nan(data.la.aggr_AD$GBQ_mean_rec)] = imput_fun(data.la.aggr_AD$GBQ_mean_rec)
data.la.aggr_AD$GBQ_persi[is.nan(data.la.aggr_AD$GBQ_persi)] = imput_fun(data.la.aggr_AD$GBQ_persi)
data.la.aggr_AD$GBQ_illus[is.nan(data.la.aggr_AD$GBQ_illus)] = imput_fun(data.la.aggr_AD$GBQ_illus)
data.la.aggr = rbind(data.la.aggr_HC,data.la.aggr_PG,data.la.aggr_AD)
write.table(data.la.aggr,file = "la_ed.txt",sep = "\t",quote = F,row.names = F)
# get the models
setwd(pfad_scripts)
source('LA_comp_mod.R')
setwd(pfad_scripts)
source('LA_comp_mod_cov.R')
source('LA_comp_mod_covc.R')
all_modc <- c(all_mod,all_modc,all_modcc)
# prep data
data.la$Age_bcp = data.la$Age
data.la$Bildungsjahre_ges_bcp = data.la$Bildungsjahre_ges
data.la$Age <- scale(data.la$Age,center=T,scale=F)
data.la$Bildungsjahre_ges <- scale(data.la$Bildungsjahre_ges,center=T,scale=F)
###########################################################
#          VD-ANALYSEN LOSS AVERSION                      #
###########################################################
# 02.11.2012
# fitting a Generalized Mixed Model to the LA data
# DV: accept.reject
# IV (fixed): Gewinn, Verlust, Group
# IV (randm): subject random
## clear workspace
rm(list = ls())
## preparation
# path
user <- "genaucka"
pfad         <- paste("C:\\Users\\", user, "\\Google Drive\\Diplom\\LA\\daten_behav_test_finale_SP_Diplom", sep="")
pfad_data    <- paste("C:\\Users\\", user, "\\Google Drive\\Diplom\\LA\\daten_behav_test_finale_SP_Diplom\\Data", sep="")
pfad_scripts <- paste("C:\\Users\\", user, "\\Google Drive\\Diplom\\LA\\daten_behav_test_finale_SP_Diplom\\Scripts", sep="")
pfad_results <- paste("C:\\Users\\", user, "\\Google Drive\\Diplom\\LA\\daten_behav_test_finale_SP_Diplom\\Results", sep="")
pfad_library <- paste("C:\\Users\\", user, "\\Google Drive\\Library\\R", sep="")
pfad_ransim  <- paste(paste(pfad_results, "\\rand_sim",sep=""))
pfad_R_cit   <- paste("C:\\Users\\", user, "\\Google Drive\\Diplom\\Manuskript\\Lit to be impl in Zotero")
# parameters
des_agg  = 3
# load libraries and functions, options (can be modified)
setwd(pfad_library)
source ('agk_library.R')
setwd(pfad_scripts)
source ('LA_options.R')
# get all the data in long format
setwd(pfad_scripts)
source("get_data_la_2.R")
# only select uncertain gambles
if (only.some == 1){
setwd(pfad_scripts)
source('only_uncertain_gambles.R')
# set the pwd needed
setwd(pfad_data)
}
setwd(pfad_scripts)
source("LA_add_demograpics.R")
# my contrasts
contrasts(data.la$group) <- cbind(c(1, 0, 0), c(0, 0, 1))
colnames(contrasts(data.la$group)) <- c("AD>HC", "PG>HC")
## get the crm
setwd(pfad_results)
load("modc51_majrev.RData")
crm <- agk.get.compl.coef(modc[[3]],"group")
names(crm) <- c("Intercept","betagain","betaloss","beta_ed_abs","group","subject")
crm <- crm[,-5]
crm$lambda <- crm$betaloss*(-1)/crm$betagain
data.la <- merge(data.la, crm, by.x = "subject", by.y = "subject", all.x = TRUE)
## saving the data for export to matlab
setwd(pfad_data)
data.la.aggr           <- aggregate(data.la, by = list(data.la$subject),FUN="first")
data.la.aggr           <- data.la.aggr[,-1]
data.la.aggr$loglambda <- get_log(data.la.aggr$lambda)
# REPLACE GBQ MISSINGS
# overall imputation function (also used later in severity)
imput_fun = function(x) {return(mean(x,na.rm=T))}
data.la.aggr_PG = subset(data.la.aggr,group == "PG")
data.la.aggr_HC = subset(data.la.aggr,group == "HC")
data.la.aggr_AD = subset(data.la.aggr,group == "AD")
data.la.aggr_AD$GBQ_mean_rec[is.nan(data.la.aggr_AD$GBQ_mean_rec)] = imput_fun(data.la.aggr_AD$GBQ_mean_rec)
data.la.aggr_AD$GBQ_persi[is.nan(data.la.aggr_AD$GBQ_persi)] = imput_fun(data.la.aggr_AD$GBQ_persi)
data.la.aggr_AD$GBQ_illus[is.nan(data.la.aggr_AD$GBQ_illus)] = imput_fun(data.la.aggr_AD$GBQ_illus)
data.la.aggr = rbind(data.la.aggr_HC,data.la.aggr_PG,data.la.aggr_AD)
write.table(data.la.aggr,file = "la_ed.txt",sep = "\t",quote = F,row.names = F)
# get the models
setwd(pfad_scripts)
source('LA_comp_mod.R')
setwd(pfad_scripts)
source('LA_comp_mod_cov.R')
source('LA_comp_mod_covc.R')
all_modc <- c(all_mod,all_modc,all_modcc)
# prep data
data.la$Age_bcp = data.la$Age
data.la$Bildungsjahre_ges_bcp = data.la$Bildungsjahre_ges
data.la$Age <- scale(data.la$Age,center=T,scale=F)
data.la$Bildungsjahre_ges <- scale(data.la$Bildungsjahre_ges,center=T,scale=F)
lae_lmlist = lmList(accept_reject ~ gain + loss + ed_abs|subject,data=data_pdt,family=binomial,na.action = NA,pool = F)
# MODEL comparison, LA study
# compare candidate models
# which one is best
# and are there differences in model fit between groups?
# there should not be because, if so, then reviewers could say:
# "Your group differences are only due to differences in model fit."
# params
# if 0 then already estimated; will only load
estimate_models = 0
# data preparation
data_pdt = data.la
data_pdt$gain = data_pdt$Gewinn
data_pdt$loss = data_pdt$Verlust
data_pdt$ed_abs = data_pdt$ed.abs
data_pdt$accept_reject = data_pdt$accept.reject
data_pdt_HC = subset(data_pdt,group == "HC")
data_pdt_PG = subset(data_pdt,group == "PG")
data_pdt_AD = subset(data_pdt,group == "AD")
setwd(paste0('C:\\Users\\', user, '\\Google Drive\\Diplom\\LA\\daten_behav_test_finale_SP_Diplom\\Scripts\\model_calculation'))
lae_lmlist = lmList(accept_reject ~ gain + loss + ed_abs|subject,data=data_pdt,family=binomial,na.action = NA,pool = F)
la_lmlist = lmList(accept_reject ~ gain + loss|subject,data=data_pdt,family=binomial,na.action = NA,pool = F)
lar_lmlist = lmList(accept_reject ~ ratio_bcp + ed_abs|subject,data=data_pdt,family=binomial,na.action = NA,pool = F)
coef(lae_lmlist)
c_lae_lmlist = coef(lae_lmlist)
c_lae_lmlist = coef(lae_lmlist)
c_lae_lmlist$lambda = -c_lae_lmlist$loss/c_lae_lmlist$gain
c_lae_lmlist$group = agk.recode.c(row.names(c_lae_lmlist),data_pdt$subject,data_pdt$group)
c_lae_lmlist = coef(lae_lmlist)
c_lae_lmlist$lambda = -c_lae_lmlist$loss/c_lae_lmlist$gain
c_lae_lmlist$group = agk.recode.c(row.names(c_lae_lmlist),data_pdt$subject,data_pdt$group)
c_la_lmlist = coef(la_lmlist)
c_la_lmlist$lambda = -c_la_lmlist$loss/c_la_lmlist$gain
c_la_lmlist$group = agk.recode.c(row.names(c_la_lmlist),data_pdt$subject,data_pdt$group)
cur_par        = lar_lmlist[ii,]
ii=1
cur_par        = lar_lmlist[ii,]
cur_par        = c_lar_lmlist[ii,]
c_la_lmlist = coef(lar_lmlist)
c_la_lmlist = coef(la_lmlist)
c_lar_lmlist = coef(lar_lmlist)
lambda_lar_lmlist = c()
cur_par               = c_lar_lmlist[ii,]
lar_lmlist = lmList(accept_reject ~ ratio_bcp|subject,data=data_pdt,family=binomial,na.action = NA,pool = F)
la_lmlist = lmList(accept_reject ~ gain + loss|subject,data=data_pdt,family=binomial,na.action = NA,pool = F)
lae_lmlist = lmList(accept_reject ~ gain + loss + ed_abs|subject,data=data_pdt,family=binomial,na.action = NA,pool = F)
c_lar_lmlist = coef(lar_lmlist)
lambda_lar_lmlist = c()
c_lar_lmlist = coef(lar_lmlist)
lambda_lar_lmlist = c()
for (ii in 1:length(lar_lmlist[,1])) {
cur_par               = c_lar_lmlist[ii,]
lambda_lar_lmlist[ii] = as.numeric(-cur_par$`(Intercept)`/cur_par$ratio_bcp)
}
c_lar_lmlist = coef(lar_lmlist)
lambda_lar_lmlist = c()
for (ii in 1:length(c_lar_lmlist[,1])) {
cur_par               = c_lar_lmlist[ii,]
lambda_lar_lmlist[ii] = as.numeric(-cur_par$`(Intercept)`/cur_par$ratio_bcp)
}
lambda_lar_lmlist[ii]
lambda_lar_lmlist
c_lar_lmlist$lambda = lambda_lar_lmlist
# the models just as lmlist
lae_lmlist = lmList(accept_reject ~ gain + loss + ed_abs|subject,data=data_pdt,family=binomial,na.action = NA,pool = F)
la_lmlist = lmList(accept_reject ~ gain + loss|subject,data=data_pdt,family=binomial,na.action = NA,pool = F)
lar_lmlist = lmList(accept_reject ~ ratio_bcp|subject,data=data_pdt,family=binomial,na.action = NA,pool = F)
# coefs lmlist
c_lae_lmlist = coef(lae_lmlist)
c_lae_lmlist$lambda = -c_lae_lmlist$loss/c_lae_lmlist$gain
c_lae_lmlist$group = agk.recode.c(row.names(c_lae_lmlist),data_pdt$subject,data_pdt$group)
c_la_lmlist = coef(la_lmlist)
c_la_lmlist$lambda = -c_la_lmlist$loss/c_la_lmlist$gain
c_la_lmlist$group = agk.recode.c(row.names(c_la_lmlist),data_pdt$subject,data_pdt$group)
c_lar_lmlist = coef(lar_lmlist)
c_la_lmlist$group = agk.recode.c(row.names(c_la_lmlist),data_pdt$subject,data_pdt$group)
lambda_lar_lmlist = c()
for (ii in 1:length(c_lar_lmlist[,1])) {
cur_par               = c_lar_lmlist[ii,]
lambda_lar_lmlist[ii] = as.numeric(-cur_par$`(Intercept)`/cur_par$ratio_bcp)
}
c_lar_lmlist$lambda = lambda_lar_lmlist
cur_mod = lm(lambda ~ group, data=c_lae_lmlist)
summary(cur_mod)
lmlists = c(c_lae_lmlist,c_la_lmlist,c_lar_lmlist)
names(lmlists)
names(lmlists)
lmlists = list(c_lae_lmlist,c_la_lmlist,c_lar_lmlist)
lmlists
names(lmlists)
names(lmlists) = c("c_lae_lmlist","c_la_lmlist","c_lar_lmlist")
print(names(lmlists)[ii])
names(lmlists) = c("c_lae_lmlist","c_la_lmlist","c_lar_lmlist")
print(names(lmlists)[ii])
names(lmlists)
ii=1
print(names(lmlists)[ii])
disp(names(lmlists)[ii])
cur_dat = lmlists[[ii]]
cur_mod = lm(lambda ~ group, data=cur_dat)
summary(cur_mod)
# group testing lmlists
for (ii in 1:length(lmlists)) {
disp(names(lmlists)[ii])
cur_dat = lmlists[[ii]]
cur_mod = lm(lambda ~ group, data=cur_dat)
print(summary(cur_mod))
print(describeBy(cur_dat$lambda,cur_dat$group))
plot(cur_dat$lambda ~ cur_dat$group)
}
ii
disp(names(lmlists)[ii])
cur_dat = lmlists[[ii]]
cur_mod = lm(lambda ~ group, data=cur_dat)
print(summary(cur_mod))
print(describeBy(cur_dat$lambda,cur_dat$group))
plot(cur_dat$lambda ~ cur_dat$group)
cur_dat$lambda
cur_dat$group
plot(cur_dat$lambda, cur_dat$group)
plot(cur_dat$lambda~as.factor(cur_dat$group))
# group testing lmlists
for (ii in 1:length(lmlists)) {
disp(names(lmlists)[ii])
cur_dat = lmlists[[ii]]
cur_mod = lm(lambda ~ group, data=cur_dat)
print(summary(cur_mod))
print(describeBy(cur_dat$lambda,cur_dat$group))
plot(cur_dat$lambda~as.factor(cur_dat$group))
}
ii
# the models just as lmlist
lae_lmlist = lmList(accept_reject ~ gain + loss + ed_abs|subject,data=data_pdt,family=binomial,na.action = NA,pool = F)
la_lmlist = lmList(accept_reject ~ gain + loss|subject,data=data_pdt,family=binomial,na.action = NA,pool = F)
lar_lmlist = lmList(accept_reject ~ ratio_bcp|subject,data=data_pdt,family=binomial,na.action = NA,pool = F)
# coefs lmlist
c_lae_lmlist = coef(lae_lmlist)
c_lae_lmlist$lambda = -c_lae_lmlist$loss/c_lae_lmlist$gain
c_lae_lmlist$group = agk.recode.c(row.names(c_lae_lmlist),data_pdt$subject,data_pdt$group)
c_la_lmlist = coef(la_lmlist)
c_la_lmlist$lambda = -c_la_lmlist$loss/c_la_lmlist$gain
c_la_lmlist$group = agk.recode.c(row.names(c_la_lmlist),data_pdt$subject,data_pdt$group)
c_lar_lmlist = coef(lar_lmlist)
c_la_lmlist$group = agk.recode.c(row.names(c_la_lmlist),data_pdt$subject,data_pdt$group)
lambda_lar_lmlist = c()
for (ii in 1:length(c_lar_lmlist[,1])) {
cur_par               = c_lar_lmlist[ii,]
lambda_lar_lmlist[ii] = as.numeric(-cur_par$`(Intercept)`/cur_par$ratio_bcp)
}
c_lar_lmlist$lambda = lambda_lar_lmlist
lmlists = list(c_lae_lmlist,c_la_lmlist,c_lar_lmlist)
names(lmlists) = c("c_lae_lmlist","c_la_lmlist","c_lar_lmlist")
# group testing lmlists
for (ii in 1:length(lmlists)) {
disp(names(lmlists)[ii])
cur_dat = lmlists[[ii]]
cur_mod = lm(lambda ~ group, data=cur_dat)
print(summary(cur_mod))
print(describeBy(cur_dat$lambda,cur_dat$group))
plot(cur_dat$lambda~as.factor(cur_dat$group))
}
ii
# the models just as lmlist
lae_lmlist = lmList(accept_reject ~ gain + loss + ed_abs|subject,data=data_pdt,family=binomial,na.action = NA,pool = F)
la_lmlist = lmList(accept_reject ~ gain + loss|subject,data=data_pdt,family=binomial,na.action = NA,pool = F)
lar_lmlist = lmList(accept_reject ~ ratio_bcp|subject,data=data_pdt,family=binomial,na.action = NA,pool = F)
# coefs lmlist
c_lae_lmlist = coef(lae_lmlist)
c_lae_lmlist$lambda = -c_lae_lmlist$loss/c_lae_lmlist$gain
c_lae_lmlist$group = agk.recode.c(row.names(c_lae_lmlist),data_pdt$subject,data_pdt$group)
c_la_lmlist = coef(la_lmlist)
c_la_lmlist$lambda = -c_la_lmlist$loss/c_la_lmlist$gain
c_la_lmlist$group = agk.recode.c(row.names(c_la_lmlist),data_pdt$subject,data_pdt$group)
c_lar_lmlist = coef(lar_lmlist)
c_lar_lmlist$group = agk.recode.c(row.names(c_lar_lmlist),data_pdt$subject,data_pdt$group)
lambda_lar_lmlist = c()
for (ii in 1:length(c_lar_lmlist[,1])) {
cur_par               = c_lar_lmlist[ii,]
lambda_lar_lmlist[ii] = as.numeric(-cur_par$`(Intercept)`/cur_par$ratio_bcp)
}
c_lar_lmlist$lambda = lambda_lar_lmlist
lmlists = list(c_lae_lmlist,c_la_lmlist,c_lar_lmlist)
names(lmlists) = c("c_lae_lmlist","c_la_lmlist","c_lar_lmlist")
# group testing lmlists
for (ii in 1:length(lmlists)) {
disp(names(lmlists)[ii])
cur_dat = lmlists[[ii]]
cur_mod = lm(lambda ~ group, data=cur_dat)
print(summary(cur_mod))
print(describeBy(cur_dat$lambda,cur_dat$group))
plot(cur_dat$lambda~as.factor(cur_dat$group))
}
# group testing lmlists
for (ii in 1:length(lmlists)) {
disp(names(lmlists)[ii])
cur_dat = lmlists[[ii]]
cur_mod = lm(lambda ~ group, data=cur_dat)
print(summary(cur_mod))
print(describeBy(cur_dat$lambda,cur_dat$group))
plot(cur_dat$lambda~as.factor(cur_dat$group))
}
